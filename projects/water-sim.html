<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Water Simulation · Janice Zhang</title>
<meta name="description" content="Water simulation with ESP32 and IMU by Janice Zhang" />

<link rel="stylesheet" href="template.css">

</head>
<body>
<header>
    <div class="nav">
      <div class="brand">Janice Zhang</div>
      <nav class="menu" aria-label="Primary">
        <a href="../index.html">Home</a>
        <a href="../experience.html">Experience →</a>
        <a href="../projects.html">Projects →</a>
        <a href="../about.html">About →</a>
      </nav>
    </div>
  </header>

<main>
  <h1>Water Simulation (FLIP + ESP32)</h1>

  <div class="divider"></div>

  <!-- OVERVIEW -->
  <section class="two-col">
    <div>
      <h2>Intro</h2>
      <p>
        I developed a working prototype that combines a 2D water simulation with live tilt data from an ESP32-WROOM and an MPU-6050 IMU, driven by Matthias Müller’s FLIP (Fluid-Implicit-Particle) method. The demo runs with low latency on a breadboard setup and produces a convincing visual effect on an LED matrix.
      </p>
      <p>
        Rather than just following fluid sim tutorials, I wanted to bridge simulation with real hardware input. The challenge was wiring a microcontroller, filtering sensor noise, and mapping motion to simulation. This project blends math, code, and electronics.
      </p>
      <a class="btn" href="https://github.com/JZhang127/Flip-Sim-Pendant">View Code on GitHub</a>
    </div>
    <figure class="seq">
        <img id="protoSeq" alt="Water simulation prototype frames" loading="eager">
    </figure>
  </section>



  <div class="divider"></div>


  <!-- Live demo, scoped so it can’t break the page -->
  <section class="flip-card">
    <h2>Live Demo (FLIP)</h2>
    <p>Move your mouse over the demo to stir the water. Toggle grid or use the joystick to tilt.</p>
    <div class="flip-wrap" id="flipDemo">
      <div class="flip-controls"><label><input id="flipGrid" type="checkbox" checked> Grid</label></div>
      <canvas id="flipCanvas" class="flip-canvas"></canvas>
      <canvas id="flipJoy" class="flip-joy" width="140" height="140"></canvas>
    </div>
  </section>

  
  
    <!-- SOFTWARE -->    
    <section class="deep-dive">
        <h2>Software Deep Dive</h2>
        <p>
            A 2D <strong>FLIP solver</strong> that couples particle dynamics with a 
            face-centred velocity grid and a pressure projection to enforce incompressibility.
        </p>

        <h3>Core Simulation Loop</h3>
        <ol>
            <li><strong>Particle advection</strong> – advance under gravity; resolve collisions.</li>
            <li><strong>Particle → grid</strong> – deposit velocities onto adjacent faces via interpolation.</li>
            <li><strong>Pressure projection</strong> – iteratively reduce divergence per cell to zero.</li>
            <li><strong>Grid → particle</strong> – interpolate corrected velocities (PIC/FLIP blend).</li>
        </ol>

        <h3>Implementation Highlights</h3>
        <ul>
            <li><strong>Spatial bucketing</strong> with prefix sums for fast neighbor queries.</li>
            <li><strong>Face-centred storage</strong> (<code>x[]</code>, <code>y[]</code>) ensures consistent momentum transfer.</li>
            <li><strong>Divergence correction</strong> adjusts all four faces per cell each iteration.</li>
            <li><strong>Stability ↔ fidelity</strong> tuned via PIC/FLIP ratio.</li>
        </ul>
    </section>

  <div class="divider"></div>

  <!-- HARDWARE -->
  <section class="deep-dive">
        <h2>Hardware Deep Dive</h2>
        



        <p>
            The system ran on an <strong>ESP32-WROOM</strong>, paired with an <strong>MPU-6050 IMU</strong> for tilt sensing and a 
            <strong>320×240 ILI9341 TFT display</strong> for visualization. Together, these components formed a complete embedded loop: sensor → simulation → display.
        </p>

        <h3>Key considerations</h3>
        <ol>
            <li>Signal stability: Raw accelerometer/gyroscope data from the MPU-6050 was noisy; I filtered and scaled it into a smooth gravity vector usable by the fluid solver.</li>
            <li>Performance limits: Running both sensor I²C reads and the FLIP simulation at 240 MHz required careful timing; I kept the loop lightweight with one solver step per frame.</li>
            <li>Rendering efficiency: Instead of redrawing the entire screen, I used a cell-based “dirty-rect” update, only clearing and repainting areas that changed. This kept the display refresh responsive at ~30 FPS.</li>
        </ol>

        <h3>Result</h3>
        <p>
            Tilting the hardware directly produced fluid motion on the screen with minimal latency, making the simulation feel responsive and physical.
        </p>
    </section>

    <section class="demo">
        <video autoplay loop muted playsinline preload="auto" class="demo-video">
            <source src="../videos/demo.mp4" type="video/mp4">
        </video>
    </section>

  <div class="divider"></div>

  <!-- PCB -->
  <section>
    <h2>PCB Design</h2>
    <p>
      Current revision uses ESP32-S3 WROOM for USB support. Two stacked double-sided PCBs: one for MCU + IMU, one for LED grid/driver.  
      This modular design allows easy expansion and keeps the build compact.
    </p>
    <p>
      I’m waiting for fabrication and parts to assemble, test, and iterate on the PCB.
    </p>
  </section>

  <img class="pretty-img" src="../images/schematic.png">
  
  <section class="two-col">
    <img class="pretty-img" src="../images/pcb.png">
    <img class="pretty-img" src="../images/led_pcb.png">
  </section>

  <div class="divider"></div>

  <section class="actions">
    <!-- <a class="btn alt" href="/projects/glucose.html">← Previous: Glucose Forecast</a> -->
    <a class="btn alt" href="engine.html">Next: Simple AI Engine →</a>
  </section>
</main>

<section id="credits">
  <div class="footer-bar">
    <div class="footer-inner">
      <span>© <span id="y"></span> Janice Zhang</span>
      <span><a href="/about.html">About</a></span>
    </div>
  </div>
</section>

<script>
  document.getElementById('y').textContent = new Date().getFullYear();
</script>

<!-- ===== FLIP demo (isolated IIFE) ===== -->
<script>
(() => {
  /* ----- Canvas sizing ----- */
  const c   = document.getElementById('flipCanvas');
  const ctx = c.getContext('2d', { alpha:false });
  const dpr = Math.max(1, devicePixelRatio || 1);
  let simHeight = 3.0, cScale = 1;

  function fit() {
    const rect = c.getBoundingClientRect();
    c.width  = Math.floor(rect.width  * dpr);
    c.height = Math.floor(rect.height * dpr);
    cScale = c.height / simHeight;
  }
  addEventListener('resize', fit);

  /* ----- Helpers ----- */
  const FLUID=0, AIR=1, SOLID=2;
  const clamp=(x,a,b)=>x<a?a:x>b?b:x;

  /* ----- FLIP core  ----- */
  class Flip{
    constructor(density,width,height,spacing,particleRadius,maxParticles){
      this.density=density;
      this.x_cells=Math.floor(width/spacing)+1;
      this.y_cells=Math.floor(height/spacing)+1;
      this.cell_num=this.x_cells*this.y_cells;
      this.cell_size=Math.max(width/this.x_cells,height/this.y_cells);

      this.x=new Float32Array(this.cell_num);
      this.prev_x=new Float32Array(this.cell_num);
      this.y=new Float32Array(this.cell_num);
      this.prev_y=new Float32Array(this.cell_num);
      this.dx=new Float32Array(this.cell_num);
      this.dy=new Float32Array(this.cell_num);
      this.pressure=new Float32Array(this.cell_num);
      this.cell_type=new Float32Array(this.cell_num);
      this.solid=new Float32Array(this.cell_num);

      this.maxParticles=maxParticles;
      this.p_pos=new Float32Array(2*maxParticles);
      this.p_vel=new Float32Array(2*maxParticles);
      this.p_density=new Float32Array(this.cell_num);
      this.p_rest_density=0.0;

      this.par_radius=particleRadius;
      this.par_spacing=2.2*particleRadius;
      this.p_x=Math.floor(width/this.par_spacing)+1;
      this.p_y=Math.floor(height/this.par_spacing)+1;
      this.pcell_num=this.p_x*this.p_y;

      this.per_cell=new Int32Array(this.pcell_num);
      this.firstCellParticle=new Int32Array(this.pcell_num+1);
      this.cellpar_id=new Int32Array(maxParticles);

      this.p_num=0;
    }
    gravity(gx,gy,dt){
      for(let i=0;i<this.p_num;i++){
        this.p_vel[2*i]+=gx*dt; this.p_vel[2*i+1]+=gy*dt;
        this.p_pos[2*i]+=this.p_vel[2*i]*dt;
        this.p_pos[2*i+1]+=this.p_vel[2*i+1]*dt;
      }
    }
    particleCollision(){
      const L=this.cell_size+this.par_radius;
      const R=(this.x_cells-1)*this.cell_size-this.par_radius;
      const B=this.cell_size+this.par_radius;
      const T=(this.y_cells-1)*this.cell_size-this.par_radius;
      for(let i=0;i<this.p_num;i++){
        let x=this.p_pos[2*i], y=this.p_pos[2*i+1];
        if(x<L){this.p_pos[2*i]=L; this.p_vel[2*i]=0}
        if(x>R){this.p_pos[2*i]=R; this.p_vel[2*i]=0}
        if(y<B){this.p_pos[2*i+1]=B; this.p_vel[2*i+1]=0}
        if(y>T){this.p_pos[2*i+1]=T; this.p_vel[2*i+1]=0}
      }
    }
    particle_grid(numIters){
      this.per_cell.fill(0);
      for(let i=0;i<this.p_num;i++){
        const x=this.p_pos[2*i]/this.par_spacing, y=this.p_pos[2*i+1]/this.par_spacing;
        const xi=clamp(Math.floor(x),0,this.p_x-1), yi=clamp(Math.floor(y),0,this.p_y-1);
        this.per_cell[xi*this.p_y+yi]++
      }
      let sum=0; for(let i=0;i<this.pcell_num;i++){ sum+=this.per_cell[i]; this.firstCellParticle[i]=sum }
      this.firstCellParticle[this.pcell_num]=sum;
      for(let i=0;i<this.p_num;i++){
        const x=this.p_pos[2*i]/this.par_spacing, y=this.p_pos[2*i+1]/this.par_spacing;
        const xi=clamp(Math.floor(x),0,this.p_x-1), yi=clamp(Math.floor(y),0,this.p_y-1);
        const cell=xi*this.p_y+yi; this.firstCellParticle[cell]--; this.cellpar_id[this.firstCellParticle[cell]]=i;
      }
      const minDist=2.0*this.par_radius;
      for(let it=0;it<numIters;it++){
        for(let i=0;i<this.p_num;i++){
          const x=this.p_pos[2*i], y=this.p_pos[2*i+1];
          const xi=Math.floor(x/this.par_spacing), yi=Math.floor(y/this.par_spacing);
          const l=Math.max(0,xi-1), r=Math.min(xi+1,this.p_x-1);
          const b=Math.max(0,yi-1), t=Math.min(yi+1,this.p_y-1);
          for(let cx=l;cx<=r;cx++){
            for(let cy=b;cy<=t;cy++){
              const s=this.firstCellParticle[cx*this.p_y+cy], e=this.firstCellParticle[cx*this.p_y+cy+1];
              for(let q=s;q<e;q++){
                const id=this.cellpar_id[q]; if(id===i) continue;
                let dx=this.p_pos[2*id]-x, dy=this.p_pos[2*id+1]-y;
                const d=Math.hypot(dx,dy); if(d>minDist||d===0) continue;
                const s2=0.5*(minDist-d)/d; dx*=s2; dy*=s2;
                this.p_pos[2*i]-=dx; this.p_pos[2*i+1]-=dy;
                this.p_pos[2*id]+=dx; this.p_pos[2*id+1]+=dy;
              }
            }
          }
        }
      }
    }
    velocity_grid(toGrid,flipRatio=0.9){
      const nX=this.x_cells,nY=this.y_cells,num=this.cell_num;
      const sz=this.cell_size, off=0.5*sz;
      if(toGrid){
        this.prev_x.set(this.x); this.prev_y.set(this.y);
        this.dx.fill(0); this.dy.fill(0); this.x.fill(0); this.y.fill(0);
        for(let i=0;i<num;i++) this.cell_type[i]=this.solid[i]===0.0?SOLID:AIR;
        for(let i=0;i<this.p_num;i++){
          const px=clamp(Math.floor(this.p_pos[2*i]/sz),0,this.x_cells-1);
          const py=clamp(Math.floor(this.p_pos[2*i+1]/sz),0,this.y_cells-1);
          const c=px*nY+py; if(this.cell_type[c]===AIR) this.cell_type[c]=FLUID;
        }
      }
      for(let comp=0;comp<2;comp++){
        const offX=comp===0?0.0:off, offY=comp===0?off:0.0;
        const gridF=comp===0?this.x:this.y, prevF=comp===0?this.prev_x:this.prev_y, gridW=comp===0?this.dx:this.dy;
        for(let p=0;p<this.p_num;p++){
          let px=clamp(this.p_pos[2*p],sz,(nX-1)*sz), py=clamp(this.p_pos[2*p+1],sz,(nY-1)*sz);
          const fx=(px-offX)/sz, fy=(py-offY)/sz;
          const i0=Math.min(Math.floor(fx),nX-2), j0=Math.min(Math.floor(fy),nY-2);
          const tx=fx-i0, ty=fy-j0, i1=i0+1, j1=j0+1;
          const w00=(1-tx)*(1-ty), w10=tx*(1-ty), w11=tx*ty, w01=(1-tx)*ty;
          const c00=i0*nY+j0, c10=i1*nY+j0, c11=i1*nY+j1, c01=i0*nY+j1;
          if(toGrid){
            const pv=this.p_vel[2*p+comp];
            gridF[c00]+=pv*w00; gridW[c00]+=w00;
            gridF[c10]+=pv*w10; gridW[c10]+=w10;
            gridF[c11]+=pv*w11; gridW[c11]+=w11;
            gridF[c01]+=pv*w01; gridW[c01]+=w01;
          }else{
            const stride=comp===0?nY:1;
            const v00=(this.cell_type[c00]!==AIR||this.cell_type[c00-stride]!==AIR)?w00:0;
            const v10=(this.cell_type[c10]!==AIR||this.cell_type[c10-stride]!==AIR)?w10:0;
            const v11=(this.cell_type[c11]!==AIR||this.cell_type[c11-stride]!==AIR)?w11:0;
            const v01=(this.cell_type[c01]!==AIR||this.cell_type[c01-stride]!==AIR)?w01:0;
            const sum=v00+v10+v11+v01; if(sum<=0) continue;
            const oldV=this.p_vel[2*p+comp];
            const picV=(v00*gridF[c00]+v10*gridF[c10]+v11*gridF[c11]+v01*gridF[c01])/sum;
            const corr=(v00*(gridF[c00]-prevF[c00])+v10*(gridF[c10]-prevF[c10])+v11*(gridF[c11]-prevF[c11])+v01*(gridF[c01]-prevF[c01]))/sum;
            this.p_vel[2*p+comp]=(1-flipRatio)*picV+flipRatio*(oldV+corr);
          }
        }
        if(toGrid){
          for(let c=0;c<num;c++) if(gridW[c]>0) gridF[c]/=gridW[c];
          for(let i=0;i<nX;i++)for(let j=0;j<nY;j++){
            const c=i*nY+j, solid=this.cell_type[c]===SOLID;
            if(solid||(i>0&&this.cell_type[c-nY]===SOLID)) this.x[c]=this.prev_x[c];
            if(solid||(j>0&&this.cell_type[c-1]===SOLID))  this.y[c]=this.prev_y[c];
          }
        }
      }
    }
    solveIncompressibility(iters,dt,omega,compensate=true){
      this.pressure.fill(0); this.prev_x.set(this.x); this.prev_y.set(this.y);
      const n=this.y_cells, cp=this.density*this.cell_size/dt;
      for(let it=0;it<iters;it++){
        for(let i=1;i<this.x_cells-1;i++){
          for(let j=1;j<this.y_cells-1;j++){
            const center=i*n+j; if(this.cell_type[center]!==FLUID) continue;
            const L=(i-1)*n+j, R=(i+1)*n+j, B=i*n+(j-1), T=i*n+(j+1);
            const sx0=this.solid[L], sx1=this.solid[R], sy0=this.solid[B], sy1=this.solid[T];
            const sum=sx0+sx1+sy0+sy1; if(sum===0) continue;
            let div=(this.x[R]-this.x[center])+(this.y[T]-this.y[center]);
            if(this.p_rest_density>0 && compensate){
              const comp=this.p_density[center]-this.p_rest_density;
              if(comp>0) div-=comp;
            }
            let p=-div/sum; p*=omega; this.pressure[center]+=cp*p;
            this.x[center]-=sx0*p; this.x[R]+=sx1*p;
            this.y[center]-=sy0*p; this.y[T]+=sy1*p;
          }
        }
      }
    }
    simulate(gx,gy,dt,flipRatio,pIters,parIters,omega,comp){
      this.gravity(gx,gy,dt);
      this.particle_grid(parIters);
      this.particleCollision();
      this.velocity_grid(true);
      this.solveIncompressibility(pIters,dt,omega,comp);
      this.velocity_grid(false,flipRatio);
    }
  }

  /* ----- Scene ----- */
  const scene={
    showGrid:true,
    ratio:0.6, p_iters:90, par_iters:3, over:1.9,
    dt:1/120, paused:false, gravityX:0.0, gravityY:-9.81, fluid:null
  };
  document.getElementById('flipGrid').addEventListener('change',e=>scene.showGrid=e.target.checked);

  /* ----- Setup ----- */
  function setup(){
    fit();
    const simWidth = c.width / cScale;
    const res=100, tankH=3.0, tankW=simWidth, h=tankH/res, density=1000.0;
    const r=0.32*h, dx=2*r, dy=2*r;
    const numX=Math.floor((0.6*tankW-2*h-2*r)/dx);
    const rows=12, total=numX*rows;

    scene.fluid=new Flip(density,tankW,tankH,h,r,total);
    const f=scene.fluid; f.p_num=total;
    for(let row=0;row<rows;row++){
      for(let i=0;i<numX;i++){
        const id=row*numX+i;
        f.p_pos[2*id]=h+r+dx*i+(row%2? r*0.5:0);
        f.p_pos[2*id+1]=h+r+dy*row;
      }
    }
    for(let i=0;i<f.x_cells;i++){
      for(let j=0;j<f.y_cells;j++){
        const idx=i*f.y_cells+j;
        const wall=(i===0||i===f.x_cells-1||j===0||j===f.y_cells-1);
        f.solid[idx]=wall?0.0:1.0;
      }
    }
  }

  /* ----- Hover disturbance (no click) ----- */
  const hover = {
    inside:false, wx:0, wy:0, lastWx:0, lastWy:0, lastT:0,
    radius:0.28,         // world units
    strength:0.4         // impulse multiplier
  };
  function toWorld(sx, sy){
    const px = sx * dpr, py = sy * dpr;
    return { wx: px / cScale, wy: (c.height - py) / cScale };
  }
  function injectImpulse(wx, wy, vx, vy){
    const f = scene.fluid;
    const R = hover.radius, R2 = R*R, S = hover.strength;
    for (let i=0;i<f.p_num;i++){
      const dx=f.p_pos[2*i]-wx, dy=f.p_pos[2*i+1]-wy;
      const d2=dx*dx+dy*dy; if(d2>R2) continue;
      const w = 1 - Math.sqrt(d2)/R;      // smooth falloff
      const k = (w*w)*S;
      f.p_vel[2*i]   += vx * k;
      f.p_vel[2*i+1] += vy * k;
    }
  }
  c.addEventListener('pointerenter', (e)=>{
    const r=c.getBoundingClientRect();
    const {wx,wy}=toWorld(e.clientX-r.left, e.clientY-r.top);
    hover.inside=true; hover.wx=hover.lastWx=wx; hover.wy=hover.lastWy=wy; hover.lastT=performance.now();
  });
  c.addEventListener('pointermove', (e)=>{
    const r=c.getBoundingClientRect();
    const now=performance.now();
    const {wx,wy}=toWorld(e.clientX-r.left, e.clientY-r.top);
    if(!hover.inside){ hover.inside=true; hover.lastWx=wx; hover.lastWy=wy; hover.lastT=now; return; }
    const dt=Math.max(1e-3,(now-hover.lastT)/1000);
    const vx=(wx-hover.lastWx)/dt, vy=(wy-hover.lastWy)/dt;
    // only inject if there's real motion
    if((vx*vx+vy*vy)>1e-6) injectImpulse(wx,wy,vx,vy);
    hover.lastWx=wx; hover.lastWy=wy; hover.wx=wx; hover.wy=wy; hover.lastT=now;
  });
  c.addEventListener('pointerleave', ()=>{ hover.inside=false; });

  /* ----- Rendering ----- */
  function draw(){
    const f=scene.fluid;
    if(!scene.showGrid){
      ctx.clearRect(0,0,c.width,c.height);
      ctx.fillStyle='royalblue';
      const rad=Math.max(2, Math.floor(3*dpr));
      for(let i=0;i<f.p_num;i++){
        const sx=f.p_pos[2*i]*cScale;
        const sy=c.height - f.p_pos[2*i+1]*cScale;
        ctx.beginPath(); ctx.arc(sx,sy,rad,0,Math.PI*2); ctx.fill();
      }
      // hover indicator
      if(hover.inside){
        ctx.save();
        ctx.globalAlpha=0.5;
        ctx.strokeStyle='#fff';
        ctx.lineWidth=2*dpr;
        ctx.beginPath();
        ctx.arc(hover.wx*cScale, c.height-hover.wy*cScale, hover.radius*cScale, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
      return;
    }
    // Grid mode
    ctx.fillStyle='#202020';
    ctx.fillRect(0,0,c.width,c.height);

    const cols=f.x_cells, rows=f.y_cells;
    const cellSim=f.cell_size*2, cellPx=cellSim*cScale;
    const occ=new Uint8Array(cols*rows);

    for(let i=0;i<f.p_num;i++){
      const x=f.p_pos[2*i], y=f.p_pos[2*i+1];
      const xi=Math.min(Math.floor(x/cellSim),cols-1);
      const yi=Math.min(Math.floor(y/cellSim),rows-1);
      occ[xi*rows+yi]=1;
    }

    ctx.save();
    const glow=getComputedStyle(document.documentElement).getPropertyValue('--water').trim()||'#67ff6e';
    ctx.shadowColor=glow; ctx.shadowBlur=10; ctx.fillStyle=glow;

    for(let cx=0;cx<cols;cx++){
      for(let cy=0;cy<rows;cy++){
        if(!occ[cx*rows+cy]) continue;
        const centerX=(cx+0.5)*cellPx;
        const centerY=c.height-(cy+0.5)*cellPx;
        const sOuter=Math.max(8*dpr, cellPx*0.6);
        const sInner=sOuter*0.35;
        ctx.fillRect(centerX-sOuter/2,centerY-sOuter/2,sOuter,sOuter);
        ctx.shadowBlur=0; ctx.fillStyle='#eaffea';
        ctx.fillRect(centerX-sInner/2,centerY-sInner/2,sInner,sInner);
        ctx.shadowBlur=10; ctx.fillStyle=glow;
      }
    }
    ctx.restore();

    // indicator in grid mode too
    if(hover.inside){
      ctx.save();
      ctx.globalAlpha=0.7;
      ctx.strokeStyle='#eaffea';
      ctx.lineWidth=2*dpr;
      ctx.beginPath();
      ctx.arc(hover.wx*cScale, c.height-hover.wy*cScale, hover.radius*cScale, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
  }

  /* ----- Joystick ----- */
  (function(){
    const joy=document.getElementById('flipJoy'), j=joy.getContext('2d');
    const W=joy.width,H=joy.height,cx=W/2,cy=H/2,baseR=55,knobR=18;
    let kx=cx,ky=cy,drag=false;
    function drawJoy(){
      j.clearRect(0,0,W,H);
      j.beginPath(); j.arc(cx,cy,baseR,0,Math.PI*2); j.fillStyle='#EEE'; j.fill();
      j.strokeStyle='#CCC'; j.lineWidth=4; j.stroke();
      j.beginPath(); j.arc(kx,ky,knobR,0,Math.PI*2); j.fillStyle='black'; j.fill();
      j.strokeStyle='#446'; j.lineWidth=2; j.stroke();
    }
    function rel(e){ const r=joy.getBoundingClientRect(); return {x:e.clientX-r.left,y:e.clientY-r.top}; }
    function move(x,y){
      let dx=x-cx,dy=y-cy; const d=Math.hypot(dx,dy)||1;
      if(d>baseR){dx=dx/d*baseR; dy=dy/d*baseR;}
      kx=cx+dx; ky=cy+dy;
      const ux=dx/(Math.hypot(dx,dy)||1), uy=dy/(Math.hypot(dx,dy)||1);
      scene.gravityX=9.81*ux; scene.gravityY=-9.81*uy;
      drawJoy();
    }
    joy.addEventListener('pointerdown',e=>{const p=rel(e); if(Math.hypot(p.x-cx,p.y-cy)<=baseR){drag=true; move(p.x,p.y)}})
    addEventListener('pointermove',e=>{ if(!drag) return; const p=rel(e); move(p.x,p.y); });
    addEventListener('pointerup',()=>{ if(!drag) return; drag=false; kx=cx; ky=cy; drawJoy(); });
    drawJoy();
  })();

  /* ----- Main loop ----- */
  function tick(){
    if(!scene.paused){
      scene.fluid.simulate(
        scene.gravityX, scene.gravityY,
        scene.dt, scene.ratio,
        scene.p_iters, scene.par_iters,
        scene.over, true
      );
    }
    draw();
    requestAnimationFrame(tick);
  }

  setup();
  tick();
})();









  // Put your 3 image paths here (order = playback order)
  const SEQ_FRAMES = [
    '../images/demo1.jpg',
    '../images/demo2.jpg',
    '../images/demo3.jpg'
  ];

  // Tune speed: lower = faster. 90–140 ms feels “bam bam bam”
  const FRAME_MS = 300;

  // Preload
  const _cache = SEQ_FRAMES.map(src => { const im = new Image(); im.src = src; return im; });

  const seqImg = document.getElementById('protoSeq');
  let idx = 0, timer = null;

  function startSeq(){
    if (timer) return;
    seqImg.src = SEQ_FRAMES[idx]; // set first frame
    timer = setInterval(() => {
      idx = (idx + 1) % SEQ_FRAMES.length;
      seqImg.src = SEQ_FRAMES[idx];
    }, FRAME_MS);
  }

  function stopSeq(){
    clearInterval(timer); timer = null;
  }

  // Auto-play when visible, pause when not (saves CPU)
  const io = new IntersectionObserver((e) => {
    e[0].isIntersecting ? startSeq() : stopSeq();
  }, { threshold: 0.2 });
  io.observe(seqImg);

  // Optional: click to pause/resume
  seqImg.addEventListener('click', () => timer ? stopSeq() : startSeq());
</script>

</body>
</html>
